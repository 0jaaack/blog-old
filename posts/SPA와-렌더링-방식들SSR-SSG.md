---
title: SPA와 렌더링 방식들(SSR, SSG)
tags:
  - react
  - browserr
published: true
date: "2022-09-10"
description: SPA의 등장-발전-한계-대안을 간략하게 살펴보는 글
---

# SPA란?
SPA는 하나의 단일 웹 문서만 로드하여 보여주는 웹 앱의 실행 방식의 일종이다. 다른 컨텐츠의 변경이 생길 때, fetch와 XMLHttpRequest 등을 이용해 웹 문서의 내용을 업데이트 하게 된다.

기존에는 변경 사항이 생길 때, 전체 새 페이지를 로드하는 방식을 사용했으나, 지금은 웹 페이지 내에서 동적으로 수정해서 사용자와 상호작용을 이루게 된다. 덕분에 하나의 웹 사이트가 하나의 앱처럼 느껴질 만큼 빠른 전환이 이루어진다.

SPA에서는 새로고침이 발생하지 않게 된다. 대신 적절한 응답에 필요한 코드를 단일 페이지로 로드해, 적절한 응답으로 동적으로 페이지가 수정된다.

# SPA의 등장과 발전
과거의 전통적인 웹사이트의 경우, 페이지 자체의 용량도 적어 새로고침이 되어 새롭게 서버에 요청을 보낸다고 해도 부담이 적었다. 점차 웹 사이트가 고도화됨에 따라, 한 페이지의 페이지 용량이 커지게 되었다. 점점 새로운 요청을 보내는 메모리 용량과 시간이 부담스러워지게 되었다.

초기에는 iframe과 AJAX를 이용하여 처리하였다. # 또는 #!(해쉬뱅)을 주소 뒤에 붙여 페이지 내에서 변경이 일어난 것 처럼 보이도록 작동하게 했다. AJAX를 이용한 방법은 한 때 권장되던 방식이었으나, 서버가 해당 URL을 제대로 된 주소로 처리하지 않게 되는 등의 문제가 발생한다.

그 이후, HTML5가 등장하고, HTML 5의 history API를 이용해 화면의 변경이 일어난 것처럼 작동하게 된다. history API는 history 스택에 정보를 넣고 꺼내, 서버로 데이터를 요청하지 않고 화면을 갱신하게 된다.

# SPA 프레임워크
현대의 많은 웹 라이브러리/프레임워크인 React, Angular, Vue은 SPA 방식을 채택하며, SPA의 확장성있고 용이한 웹 페이지 작성을 목표로 하고 있다. 대부분의 프레임워크는 Virtural DOM(가상 돔)을 사용해 SPA를 더욱 효과적으로 사용한다.

DOM 트리와 동일하게 흉내낸 Virtual DOM을 만들고, 변경사항을 저장해놨다가 한 번의 브라우저 호출로 변경사항을 변경하는 방식이다. Virtual DOM으로 인해 불필요하게 많은 DOM 조작을 방지할 수 있다.

# CSR
대부분의 SPA 프레임워크들은 CSR(Client Side Rendering)방식의 렌더링을 사용한다.

# SPA의 한계
1. SEO(Search Engine Optimization)

    SPA 방식에서 전통적으로 제기되던 문제점은 SEO(검색 엔진 최적화) 관련 문제점이다. 웹사이트 검색 엔진은, 자바스크립트를 실행하지 않고 사이트의 정보를 가져오기에 SPA로 동작하는 웹사이트를 텅 빈 사이트라고 인식하게 된다. 최근 구글이 자바스크립트를 해석하여 사이트들을 크롤링(웹 사이트의 정보를 수집)하고 있지만, 아직 한계가 존재한다.

    SEO는 많은 웹사이트들에게 아주 중요한 문제이다. 실제로 페이지를 만들어도 사용자가 유입이 되지 않는다면 의미가 없게 된다.

    이러한 문제점을 해결하기 위해, 동적 렌더링이나 SPA에 부분적으로 SSR(서버사이드 렌더링 방식)을 적용시킬 수 있는 프레임워크, 정적 사이트 생성기(SSG)를 쓰는 등의 방법이 있다.

2. 초기 렌더링 문제

    아무래도 사용자의 모든 반응과 페이지 방문에 대처하기 위해서 모든 자바크립트 코드를 불러오다보니 시간이 걸리게 된다. 사용자 경험에 있어서, 초기 렌더링 문제는 사용자 경험을 악화시키므로 여러 기술을 사용해 개선하곤 한다.

    초기 렌더링 문제들을 해결하기 위한 방안으로는 JAMStack 방식의 웹사이트 구성이 있다.

# SPA에서 내놓은 대안
1. JAMStack

    JAMStack은 Javascript와 Api, Markup으로 이루어진 웹사이트 구성 방식이다. 그 중에 마크업은, 첫 페이지의 로드를 빠르게 하기 위한 중요한 사항이다. 마크업을 생성하는 방식은 다양하다. HTML을 직접 작성할 수도 있고, Template Engine을 사용하거나, SSG(Static Site Generator)등을 사용하여 마크업을 만들어 낼 수 있다.

    클라이언트에 대한 처리는 Javascript가 맡게 되며, Api 요청을 통해 데이터를 불러오게 된다. 아래에서 설명할 Next.js, Gatsby.js 모두 JAMStack 방식의 웹사이트 구성을 할 수 있다.
2. 동적 렌더링

    서버에 웹 페이지를 요청하는 주체가 일반 사용자인지, 웹 크롤러(웹 사이트의 검색 엔진)인지 판단해 렌더링 된 HTML을 보여주는 방식이다. React에서는 대표적으로 react-helmet과 같은 것이 있다.

    하지만 이러한 방식에도 불안요소가 여전히 남아있어, SSG 방식이나 SSR 방식을 사용하기도 한다.
3. SSR(Server Side Rendering)

    SSR은 매 요청마다 HTML이 생성되는, CSR과 대조적인 방식이다. React에서 대표적인 SSR 방식 렌더링을 지원하는 프레임워크로는 Next.js가 있다.

    React에서 Next.js를 통해 SSR 방식의 렌더링을 사용하게 되면서, SEO 방식에 대처가 가능해졌다. Next.js에서는 pre-rendering 방식으로 최초 HTML 파일과 최소한의 JS 파일을 브라우저로 전송하게 한다. 부분적으로는 동적으로 페이지를 로드하는 기능(레이아웃)을 사용하여 CSR의 특성도 가지게 되었다.

    Next.js는 아래에 설명한 SSG 방식도 지원하면서 렌더링에 관한 유연한 대처가 가능해졌다.
4. SSG(Static Site Generation)

    SEO 방식을 해소하기 위한 또 다른 방법은, SSG 방식의 렌더링을 이용하는 것이다. SSG는 빌드 과정 중에 HTML 파일을 모두 생성해 배포된다. 빈 HTML에 초기 렌더링 시 사이트를 채우는 CSR 방식과는 대조적이다.

    SSG도 일종의 SSR의 방식이라고 볼 수 있지만, 자바스크립트 코드도 추가할 수 있어 CSR 방식처럼 동적인 요구도 처리할 수 있다. 대표적인 React의 SSG 라이브러리로는 Gatsby.js를 들 수 있다. Next.js도 SSG 방식을 쓸 수 있다.
      
    초기 렌더링 시간 문제에 있어서도 SSR 방식보다 SSG 방식이 조금 더 빠르게 렌더링 된다. 다만 SSG 방식은 정적인 사이트의 생성(블로그, 위키, 안내 페이지 등)에 적합한 방식이며, 조금 더 동적인(업데이트가 자주 되거나 데이터가 자주 바뀌는) 페이지의 생성에는 적합하지 않다.

    사용하는 데이터와 페이지의 규모에 따라 여러 방식을 신중하게 결정할 필요가 있다.
